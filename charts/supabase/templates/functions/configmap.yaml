{{- if and .Values.functions.enabled (not .Values.functions.existingConfigmap) }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "supabase.functions.fullname" . }}-default
  namespace: {{ include "common.names.namespace" . | quote }}
  {{- $versionLabel := dict "app.kubernetes.io/version" ( include "common.images.version" ( dict "imageRoot" .Values.functions.image "chart" .Chart ) ) }}
  {{- $labels := include "common.tplvalues.merge" ( dict "values" ( list .Values.commonLabels $versionLabel ) "context" . ) }}
  labels: {{- include "common.labels.standard" ( dict "customLabels" $labels "context" $ ) | nindent 4 }}
    app.kubernetes.io/part-of: supabase
    app.kubernetes.io/component: functions
  {{- if .Values.commonAnnotations }}
  annotations: {{- include "common.tplvalues.render" ( dict "value" .Values.commonAnnotations "context" $ ) | nindent 4 }}
  {{- end }}

data:
  index.ts: |
    import { STATUS_CODE, STATUS_TEXT } from "https://deno.land/std/http/status.ts";
    import * as posix from "https://deno.land/std/path/posix/mod.ts";
    import * as jose from "https://deno.land/x/jose@v4.13.1/index.ts";

    const SB_SPECIFIC_ERROR_CODE = {
      BootError: STATUS_CODE.ServiceUnavailable /** Service Unavailable (RFC 7231, 6.6.4) */,
      InvalidWorkerResponse: STATUS_CODE.InternalServerError /** Internal Server Error (RFC 7231, 6.6.1) */,
      WorkerLimit: 546 /** Extended */,
    };

    const SB_SPECIFIC_ERROR_TEXT = {
      [SB_SPECIFIC_ERROR_CODE.BootError]: "BOOT_ERROR",
      [SB_SPECIFIC_ERROR_CODE.InvalidWorkerResponse]: "WORKER_ERROR",
      [SB_SPECIFIC_ERROR_CODE.WorkerLimit]: "WORKER_LIMIT",
    };

    const SB_SPECIFIC_ERROR_REASON = {
      [SB_SPECIFIC_ERROR_CODE.BootError]: "Worker failed to boot (please check logs)",
      [SB_SPECIFIC_ERROR_CODE.InvalidWorkerResponse]: "Function exited due to an error (please check logs)",
      [SB_SPECIFIC_ERROR_CODE.WorkerLimit]: "Worker failed to respond due to a resource limit (please check logs)",
    };

    // OS stuff - we don't want to expose these to the functions.
    const EXCLUDED_ENVS = ["HOME", "HOSTNAME", "PATH", "PWD"];

    const JWT_SECRET = Deno.env.get("SUPABASE_INTERNAL_JWT_SECRET")!;
    const DEBUG = Deno.env.get("SUPABASE_INTERNAL_DEBUG") === "true";
    const FUNCTIONS_CONFIG_STRING = Deno.env.get("SUPABASE_INTERNAL_FUNCTIONS_CONFIG")!;
    const FUNCTIONS_HOME = Deno.env.get("SUPABASE_INTERNAL_FUNCTIONS_HOME") || "/home/deno/functions";

    // Ref: https://supabase.com/docs/guides/functions/limits
    const memoryLimitMb = parseInt(Deno.env.get("SUPABASE_INTERNAL_MEMORY_LIMIT_MB") || "256");
    const workerTimeoutMs = parseInt(Deno.env.get("SUPABASE_INTERNAL_WALLCLOCK_LIMIT_SEC") || "400") * 1000;
    const forceCreate = Deno.env.get("SUPABASE_INTERNAL_FORCE_CREATE") === "true";
    const noModuleCache = Deno.env.get("SUPABASE_INTERNAL_NO_MODULE_CACHE") === "true";
    const cpuTimeSoftLimitMs = parseInt(Deno.env.get("SUPABASE_INTERNAL_CPU_TIME_SOFT_LIMIT_MS") || "1000");
    const cpuTimeHardLimitMs = parseInt(Deno.env.get("SUPABASE_INTERNAL_CPU_TIME_HARD_LIMIT_MS") || "2000");

    // FIXME: still useful???
    // const netAccessDisable = Deno.env.get("SUPABASE_INTERNAL_NET_ACCESS_DISABLED") === "true";

    const DENO_SB_ERROR_MAP = new Map([
      [Deno.errors.InvalidWorkerCreation, SB_SPECIFIC_ERROR_CODE.BootError],
      [Deno.errors.InvalidWorkerResponse, SB_SPECIFIC_ERROR_CODE.InvalidWorkerResponse],
      [Deno.errors.WorkerRequestCancelled, SB_SPECIFIC_ERROR_CODE.WorkerLimit],
    ]);

    interface FunctionConfig {
      entrypointPath: string;
      importMapPath: string;
      ignoreJWT: boolean;
    }

    function getResponse(payload: any, status: number, customHeaders = {}) {
      const headers = { ...customHeaders };
      let body: string | null = null;

      if (payload) {
        if (typeof payload === "object") {
          headers["Content-Type"] = "application/json";
          body = JSON.stringify(payload);
        } else if (typeof payload === "string") {
          headers["Content-Type"] = "text/plain";
          body = payload;
        } else {
          body = null;
        }
      }

      return new Response(body, { status, headers });
    }

    const functionsConfig: Record<string, FunctionConfig> = (() => {
      try {
        const functionsConfig = JSON.parse(FUNCTIONS_CONFIG_STRING);
        if (DEBUG) {
          console.log("Functions config:", FUNCTIONS_CONFIG_STRING);
          console.log(functionsConfig);
        }

        return functionsConfig;
      } catch (cause) {
        throw new Error("Failed to parse functions config", { cause });
      }
    })();

    function getAuthToken(req: Request) {
      if (DEBUG) {
        console.log("Request headers:", JSON.stringify([...req.headers.entries()]));
      }
      const authHeader = req.headers.get("authorization") || req.headers.get("Authorization");
      if (!authHeader) {
        throw new Error("Missing authorization header");
      }
      const [bearer, token] = authHeader.split(" ");
      if (bearer !== "Bearer") {
        throw new Error(`Auth header is not 'Bearer {token}'`);
      }
      return token;
    }

    async function verifyJWT(jwt: string): Promise<boolean> {
      const encoder = new TextEncoder();
      const secretKey = encoder.encode(JWT_SECRET);
      try {
        await jose.jwtVerify(jwt, secretKey);
      } catch (e) {
        console.error(e);
        return false;
      }
      return true;
    }

    Deno.serve({
      handler: async (req: Request) => {
        const url = new URL(req.url);
        const { pathname } = url;

        // handle health checks
        if (pathname === "/_internal/health") {
          return getResponse({ message: "ok" }, STATUS_CODE.OK);
        }

        // handle metrics
        if (pathname === "/_internal/metric") {
          const metric = await EdgeRuntime.getRuntimeMetrics();
          return Response.json(metric);
        }

        const pathParts = pathname.split("/");
        const functionName = pathParts[1];

        // if (!functionName || !(functionName in functionsConfig)) {
        if (!functionName) {
          return getResponse("Function name not found", STATUS_CODE.NotFound);
        }

        if (req.method !== "OPTIONS" && !functionsConfig[functionName]?.ignoreJWT) {
          try {
            if (DEBUG) console.log("Verifying JWT for function", functionName);
            const token = getAuthToken(req);
            const isValidJWT = await verifyJWT(token);

            if (!isValidJWT) {
              return getResponse({ msg: "Invalid JWT" }, STATUS_CODE.Unauthorized);
            }
          } catch (e) {
            console.error(e);
            return getResponse({ msg: e.toString() }, STATUS_CODE.Unauthorized);
          }
        }
        // const importMapPath = functionsConfig[functionName].importMapPath || `${functionName}/deno.json`;
        const importMapPath = functionsConfig[functionName]?.importMapPath
          ? posix.join(FUNCTIONS_HOME, functionsConfig[functionName]?.importMapPath)
          : undefined;
        const entrypointPath = functionsConfig[functionName]?.entrypointPath || `${functionName}/index.ts`;
        const servicePath = posix.dirname(entrypointPath);
        console.error(`serving the request with ${servicePath} with importMapPath ${importMapPath}`);

        const envVarsObj = Deno.env.toObject();
        const envVars = Object.entries(envVarsObj).filter(
          ([name, _]) => !EXCLUDED_ENVS.includes(name) && !name.startsWith("SUPABASE_INTERNAL_"),
        );

        const customModuleRoot = ""; // empty string to allow any local path

        // NOTE(Nyannyacha): Decorator type has been set to tc39 by Lakshan's request,
        // but in my opinion, we should probably expose this to customers at some
        // point, as their migration process will not be easy.
        const decoratorType = "tc39";

        const absEntrypoint = posix.join(FUNCTIONS_HOME, entrypointPath);
        const maybeEntrypoint = posix.toFileUrl(absEntrypoint).href;
        try {
          const worker = await EdgeRuntime.userWorkers.create({
            servicePath,
            memoryLimitMb,
            workerTimeoutMs,
            noModuleCache,
            importMapPath,
            envVars,
            forceCreate,
            customModuleRoot,
            cpuTimeSoftLimitMs,
            cpuTimeHardLimitMs,
            decoratorType,
            maybeEntrypoint,
            context: {
              useReadSyncFileAPI: true,
            },
          });

          return await worker.fetch(req);
        } catch (e) {
          console.error(e);

          for (const [denoError, sbCode] of DENO_SB_ERROR_MAP.entries()) {
            if (denoError !== void 0 && e instanceof denoError) {
              return getResponse(
                {
                  code: SB_SPECIFIC_ERROR_TEXT[sbCode],
                  message: SB_SPECIFIC_ERROR_REASON[sbCode],
                },
                sbCode,
              );
            }
          }

          return getResponse(
            {
              code: STATUS_TEXT[STATUS_CODE.InternalServerError],
              message: "Request failed due to an internal server error",
              trace: JSON.stringify(e.stack),
            },
            STATUS_CODE.InternalServerError,
          );
        }
      },

      onListen: () => {
        console.log(`Serving functions on SUPABASE_URL/functions/v1/<function-name> Using ${Deno.version.deno}`);
      },

      onError: (e) => {
        return getResponse(
          {
            code: STATUS_TEXT[STATUS_CODE.InternalServerError],
            message: "Request failed due to an internal server error",
            trace: JSON.stringify(e.stack),
          },
          STATUS_CODE.InternalServerError,
        );
      },
    });

{{- end }}